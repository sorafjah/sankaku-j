<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>インタラクティブ三角定規セット</title>
    <style>
        /* --- 基本的なページ設定 --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f0f0f0;
        }

        /* --- SVGと操作エリアのコンテナ --- */
        #container {
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: default; /* デフォルトカーソルに */
            position: relative;
        }
        
        /* --- SVG要素のスタイル --- */
        #canvas {
            width: 100%;
            height: 100%;
            background-color: #ffffff;
        }

        /* --- 各定規のグループスタイル --- */
        .ruler-group {
            cursor: grab;
        }
        .ruler-group:active {
            cursor: grabbing;
        }

        /* --- 三角定規本体のスタイル --- */
        .ruler-body-30-60 {
            fill: rgba(135, 206, 250, 0.4); /* 水色 */
            stroke: #4a4a4a;
            stroke-width: 2;
            stroke-linejoin: round;
        }
        .ruler-body-45 {
            fill: rgba(144, 238, 144, 0.5); /* 薄い緑 */
            stroke: #4a4a4a;
            stroke-width: 2;
            stroke-linejoin: round;
        }

        /* --- 角度マークのスタイル --- */
        .angle-mark {
            fill: none;
            stroke: #333;
            stroke-width: 2;
            stroke-linecap: round;
        }
        
        /* --- 角度ラベルのスタイル --- */
        .angle-label {
            font-weight: normal; 
            fill: #111;
            text-anchor: middle;
            dominant-baseline: middle;
            paint-order: stroke;
            stroke: rgba(255, 255, 255, 0.8);
            stroke-width: 4px;
            stroke-linejoin: round;
            user-select: none;
        }

        /* --- UI要素 --- */
        .ui-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            border-radius: 50%;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            font-size: 24px;
            color: #333;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }
        .ui-button:hover { background-color: #fff; }
        .ui-button:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body>

    <div id="container">
        <svg id="canvas">
            <!-- 30-60-90 三角定規 -->
            <g id="ruler-group-30-60" class="ruler-group">
                <polygon class="ruler-body-30-60" />
                <g class="angle-marks">
                    <path class="angle-mark" data-angle="30" />
                    <path class="angle-mark" data-angle="60" />
                    <!-- 90度マークを polyline から path に戻す -->
                    <path class="angle-mark" data-angle="90" />
                </g>
                <g class="angle-labels">
                    <text class="angle-label" data-angle="30">30°</text>
                    <text class="angle-label" data-angle="60">60°</text>
                    <text class="angle-label" data-angle="90">90°</text>
                </g>
            </g>

            <!-- 45-45-90 三角定規 -->
            <g id="ruler-group-45" class="ruler-group">
                <polygon class="ruler-body-45" />
                <g class="angle-marks">
                    <path class="angle-mark" data-angle="45_1" />
                    <path class="angle-mark" data-angle="45_2" />
                    <!-- 90度マークを polyline から path に戻す -->
                    <path class="angle-mark" data-angle="90" />
                </g>
                <g class="angle-labels">
                    <text class="angle-label" data-angle="45_1">45°</text>
                    <text class="angle-label" data-angle="45_2">45°</text>
                    <text class="angle-label" data-angle="90">90°</text>
                </g>
            </g>
        </svg>
    </div>
    
    <button id="reset-button" class="ui-button" title="リセット">🔄</button>

    <script>
        // --- DOM要素 ---
        const container = document.getElementById('container');
        const svg = document.getElementById('canvas');
        const rulerGroup3060 = document.getElementById('ruler-group-30-60');
        const rulerGroup45 = document.getElementById('ruler-group-45');
        const resetButton = document.getElementById('reset-button');

        // --- 定義 ---
        const vertices3060 = {
            p30: { x: 0, y: 0 },
            p60: { x: 250 / Math.sqrt(3), y: 250 },
            p90: { x: 0, y: 250 }
        };
        const vertices45 = {
            p90: { x: 0, y: 250 },
            p45_1: { x: 0, y: 0 },
            p45_2: { x: 250, y: 250 }
        };

        // --- 状態管理 ---
        let transformState3060 = { x: 0, y: 0, scale: 1.0, angle: 0 };
        let transformState45 = { x: 0, y: 0, scale: 1.0, angle: 0 };
        const initialStates = {
            state3060: { ...transformState3060 },
            state45: { ...transformState45 }
        };
        const pointers = new Map();
        let activeRuler = null;
        let lastPointerState = { distance: 0, angle: 0, midpoint: { x: 0, y: 0 } };
        
        // --- 初期化 ---
        function initialize() {
            setupRuler(rulerGroup3060, vertices3060);
            setupRuler(rulerGroup45, vertices45);
            centerRulers();
            addEventListeners();
            requestAnimationFrame(update);
        }

        // --- セットアップ ---
        function setupRuler(rulerGroup, vertices) {
            const shape = rulerGroup.querySelector('polygon');
            const points = Object.values(vertices).map(p => `${p.x},${p.y}`).join(' ');
            shape.setAttribute('points', points);
            setupAngleIndicators(rulerGroup, vertices);
        }

        function setupAngleIndicators(rulerGroup, vertices) {
            const MARK_RADIUS = 40;
            if (vertices.p30) { // 30-60-90 ruler
                const p30 = vertices.p30, p60 = vertices.p60, p90 = vertices.p90;
                const size90 = MARK_RADIUS * 0.8;
                rulerGroup.querySelector('.angle-marks [data-angle="30"]').setAttribute('d', `M ${p30.x} ${p30.y+MARK_RADIUS} A ${MARK_RADIUS} ${MARK_RADIUS} 0 0 0 ${p30.x+MARK_RADIUS*Math.sin(30*Math.PI/180)} ${p30.y+MARK_RADIUS*Math.cos(30*Math.PI/180)}`);
                rulerGroup.querySelector('.angle-marks [data-angle="60"]').setAttribute('d', `M ${p60.x-MARK_RADIUS} ${p60.y} A ${MARK_RADIUS} ${MARK_RADIUS} 0 0 1 ${p60.x-MARK_RADIUS*Math.cos(60*Math.PI/180)} ${p60.y-MARK_RADIUS*Math.sin(60*Math.PI/180)}`);
                // 以前の正常に動作していたパスの描き方に戻します
                const pathData90 = `M ${p90.x} ${p90.y - size90} L ${p90.x + size90} ${p90.y - size90} L ${p90.x + size90} ${p90.y}`;
                rulerGroup.querySelector('.angle-marks [data-angle="90"]').setAttribute('d', pathData90);
            } else { // 45-45-90 ruler
                const p45_1 = vertices.p45_1, p45_2 = vertices.p45_2, p90 = vertices.p90;
                const size90 = MARK_RADIUS * 0.8;
                rulerGroup.querySelector('.angle-marks [data-angle="45_1"]').setAttribute('d', `M ${p45_1.x} ${p45_1.y+MARK_RADIUS} A ${MARK_RADIUS} ${MARK_RADIUS} 0 0 0 ${p45_1.x+MARK_RADIUS*Math.cos(45*Math.PI/180)} ${p45_1.y+MARK_RADIUS*Math.sin(45*Math.PI/180)}`);
                rulerGroup.querySelector('.angle-marks [data-angle="45_2"]').setAttribute('d', `M ${p45_2.x-MARK_RADIUS} ${p45_2.y} A ${MARK_RADIUS} ${MARK_RADIUS} 0 0 1 ${p45_2.x-MARK_RADIUS*Math.cos(45*Math.PI/180)} ${p45_2.y-MARK_RADIUS*Math.sin(45*Math.PI/180)}`);
                // こちらも同様に、以前の描き方に戻します
                const pathData90 = `M ${p90.x} ${p90.y - size90} L ${p90.x + size90} ${p90.y - size90} L ${p90.x + size90} ${p90.y}`;
                rulerGroup.querySelector('.angle-marks [data-angle="90"]').setAttribute('d', pathData90);
            }
        }

        function centerRulers() {
            // 30-60定規の中心を頂点データから計算
            const allX_3060 = Object.values(vertices3060).map(p => p.x);
            const allY_3060 = Object.values(vertices3060).map(p => p.y);
            const centerX_3060 = (Math.min(...allX_3060) + Math.max(...allX_3060)) / 2;
            const centerY_3060 = (Math.min(...allY_3060) + Math.max(...allY_3060)) / 2;

            transformState3060.x = (svg.clientWidth / 4) - centerX_3060;
            transformState3060.y = (svg.clientHeight / 2) - centerY_3060;
            
            // 45定規の中心を頂点データから計算
            const allX_45 = Object.values(vertices45).map(p => p.x);
            const allY_45 = Object.values(vertices45).map(p => p.y);
            const centerX_45 = (Math.min(...allX_45) + Math.max(...allX_45)) / 2;
            const centerY_45 = (Math.min(...allY_45) + Math.max(...allY_45)) / 2;

            transformState45.x = (svg.clientWidth * 3 / 4) - centerX_45;
            transformState45.y = (svg.clientHeight / 2) - centerY_45;
            
            initialStates.state3060 = { ...transformState3060 };
            initialStates.state45 = { ...transformState45 };
        }

        // --- イベントリスナー ---
        function addEventListeners() {
            container.addEventListener('pointerdown', onPointerDown);
            container.addEventListener('pointermove', onPointerMove);
            container.addEventListener('pointerup', onPointerUp);
            container.addEventListener('pointercancel', onPointerUp);
            container.addEventListener('wheel', onWheel, { passive: false });
            resetButton.addEventListener('click', resetTransforms);
        }

        function onPointerDown(e) {
            const targetRuler = e.target.closest('.ruler-group');
            if (targetRuler) {
                activeRuler = targetRuler;
                pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
                container.setPointerCapture(e.pointerId);
                if (pointers.size === 2) updateLastPointerState();
            }
        }

        function onPointerMove(e) {
            if (!activeRuler || !pointers.has(e.pointerId)) return;
            
            const state = (activeRuler.id === 'ruler-group-30-60') ? transformState3060 : transformState45;
            pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

            if (pointers.size === 1) {
                state.x += e.movementX;
                state.y += e.movementY;
            } else if (pointers.size === 2) {
                const currentPointers = Array.from(pointers.values());
                const p1 = currentPointers[0], p2 = currentPointers[1];
                const distance = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                const angle = Math.atan2(p1.y - p2.y, p1.x - p2.x);
                const midpoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };

                const scaleFactor = distance / lastPointerState.distance;
                state.x = midpoint.x + (state.x - midpoint.x) * scaleFactor;
                state.y = midpoint.y + (state.y - midpoint.y) * scaleFactor;
                state.scale *= scaleFactor;

                const angleDiff = angle - lastPointerState.angle;
                const cos = Math.cos(angleDiff), sin = Math.sin(angleDiff);
                const dx = state.x - midpoint.x, dy = state.y - midpoint.y;
                state.x = midpoint.x + (dx * cos - dy * sin);
                state.y = midpoint.y + (dx * sin + dy * cos);
                state.angle += angleDiff * (180 / Math.PI);
                
                lastPointerState = { distance, angle, midpoint };
            }
        }

        function onPointerUp(e) {
            pointers.delete(e.pointerId);
            if (pointers.size === 0) activeRuler = null;
            container.releasePointerCapture(e.pointerId);
        }
        
        function onWheel(e) {
            const targetRuler = e.target.closest('.ruler-group');
            if (!targetRuler) return;
            e.preventDefault();
            const state = (targetRuler.id === 'ruler-group-30-60') ? transformState3060 : transformState45;
            const scaleFactor = e.deltaY < 0 ? 1.1 : 0.9;
            const mousePos = { x: e.clientX, y: e.clientY };
            state.x = mousePos.x + (state.x - mousePos.x) * scaleFactor;
            state.y = mousePos.y + (state.y - mousePos.y) * scaleFactor;
            state.scale *= scaleFactor;
        }

        function updateLastPointerState() {
            const currentPointers = Array.from(pointers.values());
            if (currentPointers.length < 2) return;
            const p1 = currentPointers[0], p2 = currentPointers[1];
            lastPointerState = {
                distance: Math.hypot(p1.x - p2.x, p1.y - p2.y),
                angle: Math.atan2(p1.y - p2.y, p1.x - p2.x),
                midpoint: { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 }
            };
        }
        
        // --- 描画ループ ---
        function update() {
            const { x: x1, y: y1, scale: s1, angle: a1 } = transformState3060;
            rulerGroup3060.setAttribute('transform', `translate(${x1}, ${y1}) rotate(${a1}) scale(${s1})`);
            updateLabels(rulerGroup3060, vertices3060, transformState3060);

            const { x: x2, y: y2, scale: s2, angle: a2 } = transformState45;
            rulerGroup45.setAttribute('transform', `translate(${x2}, ${y2}) rotate(${a2}) scale(${s2})`);
            updateLabels(rulerGroup45, vertices45, transformState45);
            
            requestAnimationFrame(update);
        }

        function updateLabels(rulerGroup, vertices, state) {
            const { scale, angle } = state;
            const LOCAL_OFFSET = 35;
            const BASE_FONT_SIZE = 29; // 36の80% (28.8)に近い値に変更
            const currentFontSize = BASE_FONT_SIZE / scale;
            const currentStrokeWidth = 4 / scale;

            const applyTransform = (label, p, offsetX, offsetY) => {
                const labelX = p.x + offsetX;
                const labelY = p.y + offsetY;
                // 'label'がnullでないことを確認してから属性を設定
                if (label) {
                    label.setAttribute('x', labelX);
                    label.setAttribute('y', labelY);
                    label.setAttribute('font-size', currentFontSize);
                    label.setAttribute('stroke-width', currentStrokeWidth);
                    label.setAttribute('transform', `rotate(${-angle}, ${labelX}, ${labelY})`);
                }
            };

            if (vertices.p30) { // 30-60-90 ruler
                // セレクターを修正し、'.angle-labels' 内の要素を明示的に指定
                applyTransform(rulerGroup.querySelector('.angle-labels [data-angle="30"]'), vertices.p30, -LOCAL_OFFSET * 0.7, -LOCAL_OFFSET * 0.7);
                applyTransform(rulerGroup.querySelector('.angle-labels [data-angle="60"]'), vertices.p60, LOCAL_OFFSET * 0.8, LOCAL_OFFSET * 0.8);
                applyTransform(rulerGroup.querySelector('.angle-labels [data-angle="90"]'), vertices.p90, -LOCAL_OFFSET * 1.0, LOCAL_OFFSET * 1.0);
            } else { // 45-45-90 ruler
                // セレクターを修正し、'.angle-labels' 内の要素を明示的に指定
                applyTransform(rulerGroup.querySelector('.angle-labels [data-angle="45_1"]'), vertices.p45_1, -LOCAL_OFFSET * 0.7, -LOCAL_OFFSET * 0.7);
                applyTransform(rulerGroup.querySelector('.angle-labels [data-angle="45_2"]'), vertices.p45_2, LOCAL_OFFSET, LOCAL_OFFSET);
                applyTransform(rulerGroup.querySelector('.angle-labels [data-angle="90"]'), vertices.p90, -LOCAL_OFFSET * 1.0, LOCAL_OFFSET * 1.0);
            }
        }

        function resetTransforms() {
            transformState3060 = { ...initialStates.state3060 };
            transformState45 = { ...initialStates.state45 };
        }

        window.addEventListener('load', initialize);
    </script>
</body>
</html>










